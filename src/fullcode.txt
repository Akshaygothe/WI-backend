file: package.json
{
  "name": "wi-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --ignore-watch node_modules --poll src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "lint": "echo \"(optional) add eslint later\""
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.19.3",
    "pino": "^10.1.0",
    "pino-pretty": "^13.1.2",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.5",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^24.10.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.3"
  }
}

file: tsconfig.json
{
  // Visit https://aka.ms/tsconfig to read more about this file
  "compilerOptions": {
    // File Layout
    "rootDir": "src",
    "outDir": "dist",

    // Environment Settings
    // See also https://aka.ms/tsconfig/module
    "module": "commonjs",
    "target": "es2020",
    "types": [],
    // For nodejs:
    // "lib": ["esnext"],
    // "types": ["node"],
    // and npm install -D @types/node

    // Other Outputs
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    // Stricter Typechecking Options
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    // Style Options
    // "noImplicitReturns": true,
    // "noImplicitOverride": true,
    // "noUnusedLocals": true,
    // "noUnusedParameters": true,
    // "noFallthroughCasesInSwitch": true,
    // "noPropertyAccessFromIndexSignature": true,

    // Recommended Options
    "strict": true,
    "jsx": "react-jsx",
    "verbatimModuleSyntax": false,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true,

    "esModuleInterop": true,
    "resolveJsonModule": true
  }
}

file: src/app.ts
/** @format */

import express from "express";
import cors from "cors";
import { router } from "./routes";
import { logger } from "./utils/logger";

export const app = express();
app.use(cors());
app.use(express.json());

// simple request logging
app.use((req, _res, next) => {
  logger.info({ method: req.method, url: req.url }, "request");
  next();
});

app.use("/api", router);

// 404 + error handlers
app.use((_req, res) => res.status(404).json({ message: "Not Found" }));
app.use((err: any, _req: any, res: any, _next: any) => {
  const code = err.status || 500;
  res.status(code).json({ message: err.message || "Internal Server Error" });
});

file: src/config.ts
/** @format */

import "dotenv/config";
import * as jwt from "jsonwebtoken";

const rawAccessExpires = process.env.JWT_EXPIRES_IN ?? "15m"; // short-lived access oken
const numericAccess = Number(rawAccessExpires);
const jwtAccessExpiresIn: jwt.SignOptions["expiresIn"] = Number.isFinite(
  numericAccess,
)
  ? (numericAccess as jwt.SignOptions["expiresIn"])
  : (rawAccessExpires as jwt.SignOptions["expiresIn"]);

// refresh token expiry (longer)
const rawRefreshExpires = process.env.JWT_REFRESH_EXPIRES_IN ?? "30d";
const numericRefresh = Number(rawRefreshExpires);
const jwtRefreshExpiresIn: jwt.SignOptions["expiresIn"] = Number.isFinite(
  numericRefresh,
)
  ? (numericRefresh as jwt.SignOptions["expiresIn"])
  : (rawRefreshExpires as jwt.SignOptions["expiresIn"]);

export const config: {
  port: number;
  mongoUri: string;
  jwtSecret: string;
  jwtExpiresIn: jwt.SignOptions["expiresIn"];
  jwtRefreshSecret: string;
  jwtRefreshExpiresIn: jwt.SignOptions["expiresIn"];
} = {
  port: Number(process.env.PORT ?? 4000),
  mongoUri: process.env.MONGODB_URI ?? "mongodb://127.0.0.1:27017/worknet_dev",
  jwtSecret: process.env.JWT_SECRET ?? "",
  jwtExpiresIn: jwtAccessExpiresIn,
  jwtRefreshSecret:
    process.env.JWT_REFRESH_SECRET ?? process.env.JWT_SECRET ?? "",
  jwtRefreshExpiresIn,
};

file: src/db.ts
/** @format */

import mongoose from "mongoose";
import { logger } from "./utils/logger";

export async function connectDB(uri: string) {
  mongoose.set("strictQuery", true);
  await mongoose.connect(uri);
  logger.info("MongoDB connected");
}

file: src/server.ts
/** @format */

import { app } from "./app";
import { config } from "./config";
import { connectDB } from "./db";
import { logger } from "./utils/logger";

(async () => {
  try {
    await connectDB(config.mongoUri);
    app.listen(config.port, () =>
      logger.info(`Server on http://localhost:${config.port}`),
    );
  } catch (e) {
    logger.error(e, "failed to start");
    process.exit(1);
  }
})();

file: src/controllers/auth.controller.ts
/** @format */

import { Request, Response } from "express";
import { User } from "../models/user.model";
import bcrypt from "bcrypt";
import {
  signAccessToken,
  signRefreshToken,
  verifyRefreshToken,
} from "../utils/jwt";
import { RefreshToken } from "../models/refreshToken.model";
import { success } from "zod";

/*
 * Helper: create & persist refresh token document
 */
async function createAndStoreRefreshToken(userId: string) {
  const refreshToken = signRefreshToken(userId);
  // compute expiry data config (approx) by decoding token expiry
  const decoded: any = await (() => {
    try {
      return verifyRefreshToken<{ sub: string; exp: number }>(refreshToken);
    } catch {
      return null;
    }
  })();
  const expiresAt =
    decoded && decoded.exp
      ? new Date(decoded.exp * 1000)
      : new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);
  await RefreshToken.create({
    token: refreshToken,
    user: userId,
    expiresAt,
    revoked: false,
  });
  return refreshToken;
}

/** Signup: create user + return both tokens */
export async function signupHandler(req: Request, res: Response) {
  const { name, email, password } = req.body;
  const existing = await User.findOne({ email });
  if (existing)
    return res.status(409).json({ message: "Email already registred" });

  const passwordHash = await bcrypt.hash(password, 10);
  const user = await User.create({ name, email, passwordHash });

  const accessToken = signAccessToken(user.id);
  const refreshToken = await createAndStoreRefreshToken(user.id);

  return res.status(201).json({
    accessToken,
    refreshToken,
    user: { id: user.id, name: user.name, email: user.email },
  });
}

/** Login: validate and return both tokens */
export async function loginHandler(req: Request, res: Response) {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (!user) return res.status(401).json({ message: "Invalid credentials" });
  const ok = await bcrypt.compare(password, user.passwordHash);
  if (!ok) return res.status(401).json({ message: "Invalid credentials" });

  const accessToken = signAccessToken(user.id);
  const refreshToken = await createAndStoreRefreshToken(user.id);

  return res.json({
    accessToken,
    refreshToken,
    user: { id: user.id, name: user.name, email: user.email },
  });
}

/** Me: uses requiredUser middleware that verifies access token */
export async function meHandler(req: Request, res: Response) {
  const userId = (req as any).userId as string;
  const user = await User.findById(userId).select("name email");
  if (!user) return res.status(404).json({ message: "User not found" });
  return res.json({
    user: { id: user.id, name: user.name, email: user.email },
  });
}

/**
 * Refresh: Client sends { refreshToken } (in body).
 * We verify token signature, find DB record, ensure not revoked & not expired,
 * then rotate: mark old token revoked and issue new refresh + access tokens.
 */
export async function refreshHandler(req: Request, res: Response) {
  const { refreshToken } = req.body;
  if (!refreshToken)
    return res.status(400).json({ message: "Missing refreshToken" });

  // verify signature first
  let payload: { sub: string; exp?: number } | null = null;
  try {
    payload = verifyRefreshToken<{ sub: string; exp?: number }>(refreshToken);
  } catch {
    return res.status(401).json({ message: "Invalid refresh token" });
  }

  // find token in DB
  const tokenDoc = await RefreshToken.findOne({ token: refreshToken });
  if (!tokenDoc || tokenDoc.revoked) {
    return res
      .status(401)
      .json({ message: "Refresh token revoked or not found" });
  }

  // check expiry
  if (tokenDoc.expiresAt && tokenDoc.expiresAt.getTime() < Date.now()) {
    return res.status(401).json({ message: "Refresh token expired" });
  }

  // rotate: revoke old, create new
  tokenDoc.revoked = true;
  await tokenDoc.save();

  const userId = payload.sub;
  const newRefreshToken = await createAndStoreRefreshToken(userId);
  const newAccessToken = signAccessToken(userId);

  return res.json({
    accessToken: newAccessToken,
    refreshToken: newRefreshToken,
  });
}

/**
 * Logout: client sends { refreshToken}, we mark it revoked (logout).
 * Also accept optional Authorization header to revoke all tokens if desired.
 */
export async function logoutHandler(req: Request, res: Response) {
  const { refreshToken } = req.body;

  if (!refreshToken) {
    // optionally accept header token to revoke
    return res.status(400).json({ message: "Missing refreshToken" });
  }

  const tokenDoc = await RefreshToken.findOne({ token: refreshToken });
  if (!tokenDoc) return res.status(200).json({ success: true }); // already gone

  tokenDoc.revoked = true;
  await tokenDoc.save();
  return res.status(200).json({ success: true });
}

file: src/middlewares/requireUser.ts
/** @format */

import { Request, Response, NextFunction } from "express";
import { verifyAccessToken } from "../utils/jwt";

export function requireUser(req: Request, res: Response, next: NextFunction) {
  const header = req.headers.authorization || "";
  const token = header.startsWith("Bearer ") ? header.slice(7) : null;
  if (!token) return res.status(401).json({ message: "Missing token" });
  try {
    const payload = verifyAccessToken<{ sub: string }>(token);
    (req as any).userId = payload.sub;
    return next();
  } catch {
    return res.status(401).json({ message: "Invalid token" });
  }
}

file: src/middlewares/validateResource.ts
/** @format */

import { z } from "zod";
import { Request, Response, NextFunction } from "express";

export const validate =
  <T extends z.ZodTypeAny>(schema: T) =>
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const parsed = schema.parse({
        body: req.body,
        params: req.params,
        query: req.query,
      }) as z.infer<T>;

      if ((parsed as any).body !== undefined) req.body = (parsed as any).body;
      if ((parsed as any).params !== undefined)
        req.params = (parsed as any).params;
      if ((parsed as any).query !== undefined)
        req.query = (parsed as any).query;

      return next();
    } catch (err: unknown) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: "Validation error",
          issue: err.issues,
        });
      }

      return next(err);
    }
  };

file: src/models/user.model.ts
/** @format */

import mongoose, { Schema } from "mongoose";

export interface IUser extends mongoose.Document {
  name: string;
  email: string;
  passwordHash: string;
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      index: true,
    },
    passwordHash: {
      type: String,
      required: true,
    },
  },
  { timestamps: true },
);

export const User = mongoose.model<IUser>("User", userSchema);

file: src/models/refreshToken.model.ts
/** @format */

import mongoose, { Schema } from "mongoose";

export interface IRefreshToken extends mongoose.Document {
  token: string;
  user: mongoose.Types.ObjectId;
  revoked: boolean;
  createdAt: Date;
  expiresAt: Date;
}

const refreshTokenSchema = new Schema<IRefreshToken>(
  {
    token: {
      type: String,
      required: true,
      index: {
        unique: true,
      },
    },
    user: {
      type: Schema.Types.ObjectId,
      required: true,
      ref: "User",
      index: true,
    },
    revoked: {
      type: Boolean,
      default: false,
    },
    expiresAt: {
      type: Date,
      required: true,
      index: {
        expires: 0,
      },
    },
  },
  { timestamps: true },
);

export const RefreshToken = mongoose.model<IRefreshToken>(
  "RefreshToken",
  refreshTokenSchema,
);

file: src/routes/auth.routes.ts
/** @format */

import { Router } from "express";
import {
  loginSchema,
  refreshSchema,
  signupSchema,
} from "../schemas/auth.schema";
import { validate } from "../middlewares/validateResource";
import {
  loginHandler,
  meHandler,
  signupHandler,
  refreshHandler,
  logoutHandler,
} from "../controllers/auth.controller";
import { requireUser } from "../middlewares/requireUser";

const r = Router();
r.post("/signup", validate(signupSchema), signupHandler);
r.post("/login", validate(loginSchema), loginHandler);
r.post("/refresh", validate(refreshSchema), refreshHandler);
r.post("/logout", validate(refreshSchema), logoutHandler);
r.get("/me", requireUser, meHandler);
export default r;

file: src/routes/health.routes.ts
/** @format */

import { Router } from "express";

const r = Router();

r.get("/", (_req, res) =>
  res.json({ status: "ok", time: new Date().toISOString() }),
);

export default r;

file: src/routes/index.ts
/** @format */

import { Router } from "express";
import health from "./health.routes";
import auth from "./auth.routes";

export const router = Router();
router.use("/health", health);
router.use("/auth", auth);

file: src/schemas/auth.schema.ts
/** @format */

import { email, z } from "zod";

export const signupSchema = z.object({
  body: z.object({
    name: z.string().min(2),
    email: z.email({ message: "Please provide a valid email address" }),
    password: z.string().min(8),
  }),
});

export const loginSchema = z.object({
  body: z.object({
    email: z.email(),
    password: z.string().min(8),
  }),
});

export const refreshSchema = z.object({
  body: z.object({
    refreshToken: z.string().min(8),
  }),
});

file: src/utils/jwt.ts
/** @format */

import * as jwt from "jsonwebtoken";
import { config } from "../config";

if (!config.jwtSecret) {
  throw new Error("JWT secret is not defined. Set JWT_SECRET in env.");
}

if (!config.jwtRefreshSecret) {
  throw new Error(
    "JWT refresh secret is not defined. Set JWT_REFRESH_SECRET in env.",
  );
}

const ACCESS_SECRET = config.jwtSecret as jwt.Secret;
const REFRESH_SECRET = config.jwtRefreshSecret as jwt.Secret;

export function signAccessToken(sub: string) {
  const payload = { sub };
  const options: jwt.SignOptions = { expiresIn: config.jwtExpiresIn };
  return jwt.sign(payload, ACCESS_SECRET, options);
}

export function signRefreshToken(sub: string) {
  const payload = { sub };
  const options: jwt.SignOptions = { expiresIn: config.jwtRefreshExpiresIn };
  return jwt.sign(payload, REFRESH_SECRET, options);
}

export function verifyAccessToken<T = { sub: string }>(token: string): T {
  return jwt.verify(token, ACCESS_SECRET) as unknown as T;
}

export function verifyRefreshToken<T = { sub: string }>(token: string): T {
  return jwt.verify(token, REFRESH_SECRET) as unknown as T;
}

file: src/utils/logger.ts
/** @format */

import pino from "pino";

export const logger = pino({
  transport: {
    target: "pino-pretty",
    options: { translateTime: "SYS:standard" },
  },
});
